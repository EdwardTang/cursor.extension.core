---
description: AI rules derived by SpecStory from the project AI interaction history
globs: *
---

---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
alwaysApply: false
---

## PROJECT OVERVIEW
This project aims to build a real-time system for fulfilling food orders in a delivery-only kitchen. The system should handle order receiving, storage, and pickup concurrently.  The system must process orders according to the logic detailed in the `Challenge.md` (located in the `documentation` folder). Project implementation will follow the steps outlined in `implementation_plan.md` (located in the `documentation` folder).  A cookiecutter template, located at `gh:your-org/planexecu-coookiecutter`, will be used to scaffold new projects.  The default project slug for this template is `oppie.xyz`.

## CODE STYLE
Maintain consistent formatting. Use clear and concise variable names. Avoid unnecessary special characters. Properly format headers, lists, and tables. Ensure correct line breaks and spacing.

## FOLDER ORGANIZATION
- `.cursor/rules/`: Contains project rules (including .mdc files).
- `documentation/`: Contains downloaded project documentation.
- `oppie.xyz/`: Contains project files generated by the cookiecutter template.
- `oppie.xyz/watcher/`: Contains the watcher script and its dependencies.
- `start_codex.sh`: Contains the script to launch Codex Planner in a new zsh terminal.
- `.cursor/`: Contains Cursor-related files.
- `.vscode/`: Contains VS Code task definitions.
- `.specstory/`: Contains SpecStory interaction history and backups.
- `codex.md`: Contains Planner instructions/guidelines.
- `send_codex_plan_request.sh`: Script to send plan requests to Codex Planner.


## TECH STACK
(To be defined based on project needs. The provided example uses Java, Kotlin, Go, C++, and C# scaffolding.)  The system must use a language that truly supports concurrency (e.g., avoid NodeJS with some Python runtimes).  Additional tech stack details may be found in `documentation/tech_stack_document.md` and `.cursor/tech_stack.md`.  The system should utilize `pyautogui` or Agent-S for GUI automation in the PlanExecu loop recovery mechanism.  The PlanExecu loop recovery mechanism utilizes Python 3.x with the `pyautogui` library for GUI automation. Once `pyautogui` is installed and setup, and the watcher's dependencies are installed, the watcher script should be run to automatically initialize Cursor wrapping. The watcher should focus on ensuring that Cursor Assistant Bubbles end with the mandatory Plan Request formatted with `@drop-in_template_A.mdc`.  After installing `pyautogui` and the watcher's dependencies, running the watcher script should automatically initialize Cursor wrapping and monitor for missing `@drop-in_template_A.mdc` in Assistant Bubbles. If missing, it should trigger the GUI recovery mechanism. A `start_cursor_with_watcher.sh` script should launch Codex Planner and the watcher simultaneously.  This script should be added to `.vscode/tasks.json` with the label "Start Codex Planner and Watcher" and the `runOn` option set to "folderOpen".  The `mcp-alchemy` library (accessed via the `uvx` command-line tool) provides access to the CursorGlobalState database.  Example usage:

```json
"my_sqlite_db": {
      "command": "uvx",
      "args": ["--from", "mcp-alchemy==2025.04.16.110003",
               "--refresh-package", "mcp-alchemy", "mcp-alchemy"],
      "env": {
        "DB_URL": "sqlite:////Users/yongbingtang/Library/Application Support/Cursor//User/globalStorage/state.vscdb"
      }
    }
```

## PROJECT-SPECIFIC STANDARDS
- All orders must be processed according to the logic described in the  `Challenge.md`
- The system must capture all actions (place, move, pickup, discard) with timestamps and order IDs.  The activity log should clearly track the complete order processing, starting with 'place' and ending with 'pickup' or 'discard'.
- The order discard selection criteria must be documented in the README.
- The system should strive to store orders at their ideal temperature.  Orders have an ID, name, ideal temperature (hot, cold, or room temperature), and shelf life; shelf life is halved if not stored at the ideal temperature.
- When the ideal storage is full, orders must be placed on the shelf.
- If the shelf is full, a cold or hot order on the shelf must be moved to the cooler or heater (if space is available) before discarding an order.
- Orders must be removed quickly for pickup without moving other orders.
- No action is taken if an order is not present during pickup.
- A command-line executable must simulate system behavior, fetching orders from the challenge server, placing orders based on configurable parameters (order rate and pickup time intervals), and submitting actions to the server for verification.  The submission must include an `x-test-id` header for identification and a JSON request body containing execution options and actions.


## WORKFLOW & RELEASE RULES
(To be defined based on project needs)  The system must be able to handle high concurrency. Download and process documentation as per steps outlined in `documentation/2025-04-15_10-42-url-content-check-and-project-implementation-steps.md`.  The URL previously referenced is now accessible and the documentation has been downloaded.  Files ending in ".mdc" should be moved to the `.cursor/rules/` directory.  Troubleshooting for "Cursor MCP sqlite server not found" issues should follow the steps outlined in `documentation/2025-04-26_05-40-sqlite-server-not-found-troubleshooting.md`.  Implement a PlanExecu Tight Loop with self-resume capability when Cursor reaches the 25 tool call limit, utilizing  `@drop-in_template_A.mdc`, `@.cursorrules`, `@Agent_Recursive_Prompt_wrapper.md`, `@codex.md`, and `@https://github.com/simular-ai/Agent-S?utm_source=chatgpt.com` as building blocks.  Focus on self-resume capability; relaxation is not required in this initial implementation. The system must implement a self-recovery mechanism when the "Exceeded 25 native tool calls" error is detected in the Cursor Executor's output. This mechanism should immediately paste the following text into a new Cursor Composer message and press Enter: "Cursor Executor, on top of @.cursorrules, @tech_stack.md and @scratchpad.md, strictly follow instructions from Codex Planner in the `Template Axâ€” Plan-and-Execute Loop` above to continue at where you stopped".  If recovery fails, an alert must be raised in the CLI. The recovery mechanism should aim for a success rate of at least 99%.  A cookiecutter template is available to scaffold new projects with the necessary files (`.cursorrules`, `drop-in_template_A.mdc`, `codex.md`, `scratchpad.md`). A Python script (located in `oppie.xyz/watcher/watcher.py`) monitors the Cursor Executor's output for the "Exceeded 25 native tool calls" error and triggers the self-recovery mechanism using `pyautogui`.  After installing `pyautogui` and the watcher's dependencies, the watcher script should be run to automatically initialize Cursor wrapping. A `start_codex.sh` script is provided to launch Codex Planner with the command `codex -m o3 -a full-auto --notify --debug` in a new zsh terminal (macOS) or the current shell (other OS).  The `start_codex.sh` script should be configured to run automatically when the project is opened in Cursor, using the Cursor tasks mechanism.  A `.vscode/tasks.json` file should be included in the cookiecutter template to achieve this.  The `.vscode/tasks.json` file should contain a task with the label "Start Codex Planner (o3 full-auto)", the command "./start_codex.sh", and the runOn option set to "folderOpen".  A new task, "Start Codex Planner with Watcher", should be added to `.vscode/tasks.json` to automatically run the watcher script along with `start_codex.sh` when the project folder is opened.  This task should use the command "python", with arguments pointing to the watcher script and `start_codex.sh`. The `runOn` option for this task should be set to "folderOpen". A new task, "Start Codex Planner and Watcher", should be added to `.vscode/tasks.json` to run `start_cursor_with_watcher.sh` when the project folder is opened.  The `runOn` option for this task should be set to "folderOpen". The watcher should also check for the presence of `@drop-in_template_A.mdc` at the end of each assistant bubble and trigger recovery if missing.  If the watcher encounters an unhandled situation, it should take a screenshot or copy the last 20 lines of the Cursor Executor output, send this to GPT-4-o-mini for text extraction, and then ask Codex Planner for instructions using a formatted prompt.  Codex Planner should respond with instructions for the watcher, prefixed with "Dev-loop watcher, please...", which the watcher will then execute.  The `send_codex_plan_request.sh` script is essential for the Plan-Execute loop, even with `@drop-in_template_A.mdc` in place, as it acts as the execution mechanism, sending the filled template to Codex Planner and retrieving the response.  The episode (iteration number) in the loop can be tracked by incrementing a counter in the `scratchpad.md` file each time `send_codex_plan_request.sh` is successfully executed.  This counter should be included in the `@drop-in_template_A.mdc` to provide context to the Codex Planner.  The system should automatically commit changes to a new branch named `recursive-loop` with the commit message "template a center .cursorrules created" when the `@drop-in_template_A.mdc` file is created or modified.  If a Git error occurs during the commit process (e.g., due to GPG signing issues), the commit should be attempted again without GPG signing using `git commit --no-gpg-sign -m 'template a center .cursorrules created'`.


## REFERENCE EXAMPLES
The  `Challenge.md`  serves as a reference for project requirements and API specifications. The `scaffold.zip` file provides scaffolding code in several languages. The `Challenge` server API (detailed in `Challenge.md`) is used for testing. `Initial_design_o1pro.md`, `Questionaire_CodeGuide.md`, and documentation downloaded from the URL specified in WORKFLOW & RELEASE RULES (now located in the `documentation` folder) are also relevant reference documents.  Additional documentation can be found in the `documentation` folder, including `implementation_plan.md`, `security_guideline_document.md`, `cursor_project_rules.md`, `backend_structure_document.md`, `app_flowchart.md`, `tech_stack_document.md`, `app_flow_document.md`, `project_requirements_document.md`, `2025-04-26_05-40-sqlite-server-not-found-troubleshooting.md`, `2025-04-26_23-18-chinook-database-exploration-and-schema-retrieval.md`, `2025-04-26_23-45-simple-prd-for-semi-autonomous-planexecu-loop.md`, `README_PLANEXECU.md`, `@scratchpad.md`, `@prd.md`, `.cursor/tech_stack.md`, `2025-04-27_20-13-design-proposal-for-cursorrules.md`.

## PROJECT DOCUMENTATION & CONTEXT SYSTEM
The primary documentation is the `Challenge.md` file , which details the project requirements and API specifications. `Initial_design_o1pro.md`, `Questionaire_CodeGuide.md`, and the contents of the `documentation` folder should be consulted for additional information.  The README must include build and run instructions, and the order discard strategy and rationale.  At least one meaningful test case demonstrating concurrent logic or the order discard strategy must be included.  The `README_PLANEXECU.md` file provides quick start instructions for the PlanExecu loop.  The `@prd.md` file details the product requirements document.

## DEBUGGING
(To be defined based on project needs)  Refer to `documentation/2025-04-26_05-40-sqlite-server-not-found-troubleshooting.md` for troubleshooting steps related to "Cursor MCP sqlite server not found" errors.  Troubleshooting steps include checking the database file path and permissions, manually testing the startup command, restarting Cursor, checking for Cursor updates, and checking Cursor's internal settings.  If the issue persists, further investigation or contacting Cursor support may be necessary.  Accessing the database file on macOS can be done visually through Finder (by holding Option and selecting Library) or via the terminal using commands like `cd`, `ls`, and `sqlite3`.  To grant full disk access to `uvx mcp-server-sqlite`, either grant full disk access to the terminal application used to run the command or, for more granular control, grant access to the `uvx` and/or `mcp-server-sqlite` executables themselves via System Settings -> Privacy & Security -> Full Disk Access.  This may require restarting the application or terminal.


## FINAL DOs AND DON'Ts
- **DO** follow the order placement and pickup logic precisely as described in the  `Challenge.md` .
- **DO** ensure concurrency is handled correctly.
- **DO** include comprehensive comments in your code.
- **DO** thoroughly test your solution.
- **DO** follow the implementation plan in `documentation/implementation_plan.md` if available.
- **DO** implement a PlanExecu Tight Loop with self-resume capability at the 25 tool call limit using the specified resources and the self-recovery mechanism described in WORKFLOW & RELEASE RULES.
- **DO** utilize the provided cookiecutter template to scaffold new projects.
- **DO** use Python 3.x and `pyautogui` for the self-recovery mechanism.
- **DO** use the `start_codex.sh` script to launch Codex Planner.
- **DO** use the `start_cursor_with_watcher.sh` script to launch Codex Planner and the watcher simultaneously.
- **DO** automatically commit changes to a new branch named `recursive-loop` with the commit message "template a center .cursorrules created" when the `@drop-in_template_A.mdc` file is created or modified.  If the commit fails due to GPG signing issues, retry the commit without GPG signing using `git commit --no-gpg-sign -m 'template a center .cursorrules created'`.
- **DON'T** use languages that don't support true concurrency (e.g., NodeJS with some Python runtimes).
- **DON'T** move orders unnecessarily during pickup.
- **DON'T** neglect error handling.


** Challenge.md Summary:**

This challenge requires building a real-time system for handling order receiving, storage, and pickup in a delivery-only kitchen. Orders have IDs, names, ideal temperatures (hot, cold, or room temperature), and shelf life; shelf life is halved if not stored at the ideal temperature. The system must support concurrent operations and follow this logic: Upon receiving a new order, the system attempts to place it in its ideal storage: refrigerator (6 cold orders max), heater (6 hot orders max), or room-temperature shelf (12 orders max). If the ideal storage is full, it goes to the shelf; if the shelf is full, it tries moving a cold/hot order from the shelf to the refrigerator/heater (if space is available). If no space is available, an order on the shelf must be discarded. Pickup requires quickly locating and removing the order without moving others. If the order is absent, no action is taken. The system must log all actions (place, move, pickup, discard) with timestamps and order IDs.  A command-line executable is required to simulate system behavior, fetching orders from the challenge server based on configurable parameters (order rate and pickup time intervals) and submitting actions for verification.  The submission must include an `x-test-id` header and a JSON request body.  The system must handle high concurrency.

## CursorGlobalState Database Schema

The `CursorGlobalState` database contains two tables:

1.  **`ItemTable`**:
    *   `key`: TEXT (nullable)
    *   `value`: BLOB (nullable)

2.  **`cursorDiskKV`**:
    *   `key`: TEXT (nullable)
    *   `value`: BLOB (nullable)

Both tables store key-value pairs where the key is text and the value is a binary large object.  Analysis of `ItemTable` suggests it stores general configuration or state related to VS Code extensions, color schemes, and internal markers.  `cursorDiskKV` appears to store data related to specific bubbles within a composer session, potentially different states or versions associated with a bubble.  The keys in `cursorDiskKV`  strongly suggest a link to bubbles (e.g., `bubbleId:<some_id>:<another_id>`).  There are two types of bubbles identified: type 1 (likely user input) and type 2 (likely assistant response/action).

## Cursor Composer Session Structure

A Cursor Composer session consists of multiple bubbles.  Each bubble has a `bubbleId` and a `type` (1 or 2).  A `checkpointId` and `afterCheckpointId` may exist within or between bubbles to represent saved states.  Code blocks are generated or modified within bubbles.  The `cursorDiskKV` table likely stores state snapshots linked to checkpoints associated with bubbles.  The relationship between Composer Session, Bubble, Checkpoint, CodeBlock, and `cursorDiskKV` is complex and requires further investigation.  An ER diagram is needed to visualize the relationships.  The relationship between bubbles and checkpoints is many-to-many.  There are two types of bubbles: type 1 (likely user input) and type 2 (likely assistant response/action).  Tool calls are included within type 2 bubbles.  Checkpoints capture the state of the session before and after a bubble is processed, including any tool calls within that bubble.  The `cursorDiskKV` table stores state snapshots linked to these checkpoints.  `afterCheckpointId` marks the session state *after* a bubble is processed, providing a precise pointer to the state after the bubble's actions (text generation, tool calls, code modifications). Comparing `checkpointId` and `afterCheckpointId` shows changes introduced by the bubble.  There are two types of bubbles: type 1 (likely user input) and type 2 (likely assistant response/action).  A tool call is part of a type 2 bubble; checkpoints capture the state before and after a bubble's processing, including any tool calls.  There are two types of bubbles: type 1 (user input) and type 2 (assistant response/action).  A tool call is part of a type 2 bubble.  Checkpoints capture the state before and after a bubble's processing, including any tool calls.  Restoring to a checkpointId A will reset the current session state to checkpoint A, removing all bubbles and checkpoints after checkpoint A.  The original checkpoint A and afterCheckpointId A' will remain unchanged.

## Plan-Execu Tight Loop â€” Simple PRD for Self-Recovery MVP (v0.2)

---
## 1. Overview
Build a minimal, semi-autonomous *Planner â‡„ Executor* loop within the Cursor IDE. The **sole focus** of this MVP is to automatically detect when the Cursor Executor hits its "25 native tool calls" limit and immediately trigger a recovery mechanism via GUI automation to continue the loop.

## 2. Problem Statement
The current manual Planner-Executor workflow is interrupted when Cursor's tool call limit is reached, requiring human intervention to restart the process. This MVP aims to create a simple, automated recovery mechanism.

## 3. Guiding Principles
1.  **Simplicity First**: Implement only the core recovery logic.
2.  **Minimal Intrusion**: Interact with Cursor externally via GUI automation; avoid internal modifications.
3.  **Observability**: Log basic recovery actions (success/failure).

## 4. Functional Requirements
| ID      | Requirement                                                                         |
| :------ | :---------------------------------------------------------------------------------- |
| FR-S1   | Monitor Cursor Executor's stdout/stderr for the exact string `Exceeded 25 native tool calls`. |
| FR-S2   | Upon detection of the error string, immediately trigger a GUI automation script.    |
| FR-S3   | The GUI script must focus the Cursor Composer's new message input window.           |
| FR-S4   | The GUI script must type the following fixed recovery prompt and press Enter:       |
|         | `Cursor Executor, on top of @.cursorrules, @tech_stack.md and @scratchpad.md, strictly follow instructions from Codex Planner in the \`Template Aâ‚“ â€” Plan-and-Execute Loop\` above to continue at where you stopped` |
| FR-S5   | Log a simple `RECOVER_TRIGGERED` message when the error is detected and `RECOVER_TYPED` when the GUI action completes. |

> **Note:** No backoff, retry logic, Reflexion, diffing, or alignment checks are included in this MVP.

## 5. Nonâ€‘Functional Requirements
*   **Reliability**: The GUI automation script should successfully type the prompt within ~5 seconds of error detection.
*   **Simplicity**: The recovery logic should reside in a small, standalone script (e.g., Python).
*   **Dependencies**: Minimal external dependencies (e.g., `pyautogui` or similar).

## 6. Success Metrics (MVP)
*   Successfully trigger and execute the recovery prompt insertion via GUI automation every time the "25 native tool calls" error is detected during testing.
*   Observe `RECOVER_TYPED` logs corresponding to each recovery event.

## 7. Stakeholders
*   **Eddie** â€” Product/Tech owner.

## 8. Scope
**Mustâ€‘have:** FR-S1, FR-S2, FR-S3, FR-S4, FR-S5.
**Out of Scope (for MVP):** Reflexion, diff analysis, alignment checks, complex error handling, backoff/retry mechanisms, persistent state tracking beyond basic logging.

---
## 9. Highâ€‘Level Architecture (Simplified)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        plan text        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Codex   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚  Cursor   â”‚
â”‚ Planner â”‚ â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ Executor  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â–²        error watch
            â”‚          (stdout/stderr)
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Tiny Watcher & Typer Script   â”‚
        â”‚ â€¢ Monitor executor output     â”‚
        â”‚ â€¢ Regex detect error          â”‚
        â”‚ â€¢ pyautogui.typewrite(...)    â”‚
        â”‚ â€¢ pyautogui.press('enter')    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow (Simplified)
1.  Planner (e.g., via `codex` tool) generates a plan (Template Aâ‚“).
2.  User/Script pastes Plan into Cursor Executor.
3.  Executor runs, potentially hitting the 25-tool limit.
4.  The separate "Watcher & Typer" script monitors Executor's output.
5.  If the error string is detected, the script triggers GUI automation (FR-S2 to FR-S4).
6.  The recovery prompt restarts the Executor's process for the next step based on the *last* plan provided by the Planner (referenced implicitly in the prompt).
7.  The loop continues.

---
## 10. Key Components & Logic
| Component               | Tech             | Notes                                                                 |
| :---------------------- | :--------------- | :-------------------------------------------------------------------- |
| **Error Detection**     | Regex/String Match | Monitor stdout/stderr of the process running the Cursor interaction. |
| **GUI Automation**      | `pyautogui`      | Focuses Cursor window, types fixed prompt, presses Enter.             |
| **Watcher/Typer Script**| Python           | Orchestrates detection and triggering of GUI automation.              |

---
## 11. Techâ€‘Stack Choices (MVP)
| Layer            | Primary     | Notes                             |
| :--------------- | :---------- | :-------------------------------- |
| Language         | Python 3.x  | For the Watcher/Typer script.     |
| GUI Automation   | `pyautogui` | Cross-platform basic GUI control. |
| Core Loop Files  | Markdown    | `.cursorrules`, `*.mdc`, `*.md`   |

---
## 12. Deployment & Setup (via Cookiecutter)

To simplify setup in any user repository, a Cookiecutter template will be provided.

### Cookiecutter Template Structure
```
planexecu-cookiecutter/
â”œâ”€â”€ cookiecutter.json                  # Defines default project_slug
â”œâ”€â”€ {{cookiecutter.project_slug}}/     # Default: oppie.xyz/
â”‚   â”œâ”€â”€ .cursorrules                   # Core Cursor rules for the loop
â”‚   â”œâ”€â”€ drop-in_template_A.mdc         # Standard Planner -> Executor template
â”‚   â”œâ”€â”€ codex.md                       # Planner instructions/guidelines
â”‚   â”œâ”€â”€ scratchpad.md                  # Initial state/scratchpad file
â”‚   â”œâ”€â”€ README_PLANEXECU.md            # Quick start guide
â”‚   â””â”€â”€ .vscode/tasks.json             # Task to automatically run start_codex.sh and watcher
â””â”€â”€ hooks/
    â””â”€â”€ post_gen_project.py            # Prints setup instructions after generation
```

### Cookiecutter Usage
1.  Install prerequisites: `pip install cookiecutter openai-codex`
2.  Set `OPENAI_API_KEY` environment variable.
3.  Install Cursor IDE.
4.  Run: `cookiecutter gh:your-org/planexecu-cookiecutter` (replace `your-org` appropriately)
5.  Accept the default `project_slug` ("oppie.xyz") or provide a custom name.
6.  Copy/merge the generated files (`.cursorrules`, `*.md`, `*.mdc`, `.vscode/tasks.json`) into the root of the target repository.
7.  Follow instructions in `README_PLANEXECU.md` to start the loop.

*(The Watcher/Typer script itself is not part of the Cookiecutter template in this design but should be provided separately or documented for the user to implement/run).*

---
## 13. Security & Privacy
*   GUI automation script should be run locally by the user.
*   Ensure the script only interacts with the intended Cursor window if possible (e.g., via window title).

---
## 14. Open Questions
1.  Confirm the exact error string output by Cursor when the 25-tool limit is hit.
2.  Determine the most reliable way for `pyautogui` to find and focus the Cursor input window across different OS/setups.
3.  How will the Watcher/Typer script be distributed and run alongside Cursor/Codex? (Needs clear instructions in the main project README).

## .cursor/tech_stack.md

# Oppie.xyz â€” Plan-Execu Tight Loop & Self-Recovery MVP Tech Stack Document

This document details the chosen technologies and design rationale for implementing the **Planner â‡„ Executor Tight Loop with automatic self-recovery** as specified in the PRD (`.cursor/prd.md`).  The structure and format mirror the example in `cloud_kitchen_tech_stack.md` for consistency.

---
## 1. System Architecture Overview â€“ Self-Recovery Loop

```mermaid
graph TD
    subgraph Cursor IDE (Single Workstation)
        Planner[Codex Planner (o3 model)]
        Executor[Cursor Executor]
        WatcherTyper[Watcher & Typer Script]
    end

    Planner -- "Generate Plan  â¤µ" --> Executor
    Executor -- "Tool Calls / Output" --> WatcherTyper
    WatcherTyper -- "Recovery Prompt (GUI)" --> Executor
    Executor -- "Continues Execution" --> Planner
```

**Key Points**
1.  The **Watcher & Typer Script** runs *outside* Cursor, monitoring the Executor's stdout/stderr.
2.  Upon detecting the fatal limit error (`Exceeded 25 native tool calls`), it uses **GUI automation** to paste a fixed recovery prompt, seamlessly continuing the loop without human intervention.

---
## 2. Core Data Flows â€“ MVP

### 2.1 Error Detection & Recovery Flow

```mermaid
sequenceDiagram
    participant E as Cursor Executor (process)
    participant W as Watcher & Typer (Python)
    participant G as OS GUI

    E->>W: stdout/stderr stream
    Note right of W: Regex match for<br/>`Exceeded 25 native tool calls`
    W--)E: RECOVER_TRIGGERED (log)
    W->>G: Focus Cursor window
    W->>G: Type fixed recovery prompt
    W->>G: Press Enter âŽ
    W--)E: RECOVER_TYPED (log)
    E->>E: Continues next batch of tool calls
```

---
## 3. Core Technology Choices

### 3.1 Programming Language: **Python 3.x**

| Pros | Cons |
|------|------|
| Widely available on macOS/Linux/Windows | Requires separate runtime installation on some machines |
| Rich standard libraries for subprocess I/O & regex | Potential version drift between 3.8 â†” 3.12 |
| Excellent ecosystem for GUI automation (pyautogui, pywin32) | Slight overhead compared to compiled binaries |
| Rapid scripting & small footprint | None critical for this MVP |

**Decision Reasoning**  
The MVP demands a light, standalone script with minimal dependencies. Python balances ease-of-use, cross-platform support, and quick development time.

**Alternatives Considered**
1. **Go** â€“ single static binary, but GUI automation libraries are immature.  
2. **Node.js** â€“ added runtime, heavier memory footprint.

---
### 3.2 GUI Automation Library: **pyautogui**

| Pros | Cons |
|------|------|
| Pure-Python, no platform-specific build required | Relies on screen coordinates â€“ fragile to UI changes |
| Cross-platform (macOS, Windows, Linux) | Limited window-focusing primitives (may require extra libs) |
| Simple API (`typewrite`, `press`) | Security prompts on macOS (Accessibility permissions) |

**Decision Reasoning**  
`pyautogui` offers the simplest path to simulate keystrokes and quickly focus the Cursor input field. For the MVP, robustness against large UI changes is not critical.

**Alternatives Considered**
1. **AppleScript / Automator** (macOS-only) â€“ not cross-platform.  
2. **SikuliX** â€“ heavyweight (Java + OpenCV) for image recognition.

---
### 3.3 Error Stream Monitoring: **`subprocess` + Regex**

*Implementation Sketch*
```python
import re, subprocess, logging

ERROR_RE = re.compile(r"Exceeded 25 native tool calls")

with subprocess.Popen(
        ["cursor", "run"],  # pseudocode â€“ actual command launching Executor
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
) as proc:
    for line in proc.stdout:
        logging.info(line.rstrip())
        if ERROR_RE.search(line):
            trigger_recovery()
```

| Pros | Cons |
|------|------|
| Zero external deps (stdlib only) | Needs robust process spawning for various user setups |
| Regex is fast & deterministic | Requires user to wrap Executor invocation via this script |
| Easy to unit-test with mocked streams | - |

---
### 3.4 Concurrency Model: **Single-Thread + Non-Blocking Read**

*Rationale*: Stdout stream handling and GUI typing are lightweight; a single thread using `select`/`poll` or `iter(pipe)` suffices.  No heavy concurrency primitives are needed.

*Future-Proofing*: If we later introduce WebSocket log streaming or multiple Executor processes, we can refactor to `asyncio` or a small thread-pool without design upheaval.

---
### 3.5 Logging: **Python `logging` Module**

*Usage Pattern*
```python
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s: %(message)s",
)
logging.info("RECOVER_TRIGGERED")
```

| Pros | Cons |
|------|------|
| Built-in, thread-safe | None for this scale |
| Supports rotating files via `RotatingFileHandler` | - |

---
### 3.6 Packaging & Distribution

| Tool | Purpose |
|------|---------|
| `pip` / `requirements.txt` | Install `pyautogui` + pinned versions |
| **Virtualenv** (optional) | Isolate dependencies |
| **Homebrew Formula (future)** | One-line install on macOS |

A minimal `requirements.txt`:
```
pyautogui==0.9.54
```

> Mac users must grant *Accessibility* permissions to the terminal (or Python) the first time `pyautogui` attempts keystrokes.

---
## 4. Infrastructure & Deployment

### 4.1 Repository Layout (Key Files & Folders)
```text
oppie.xyz/
â”œâ”€â”€ .cursorrules                # Core Cursor rules (includes drop-in continuation guard-rails)
â”œâ”€â”€ .vscode/
â”‚   â””â”€â”€ tasks.json              # Auto-runs start_codex.sh and watcher on folder open
â”œâ”€â”€ .specstory/                 # SpecStory history & backups
â”‚   â”œâ”€â”€ history/
â”‚   â””â”€â”€ ai_rules_backups/
â”œâ”€â”€ .cursor/
â”‚   â”œâ”€â”€ tech_stack.md           # <-- this document
â”‚   â”œâ”€â”€ prd.md                  # Simple PRD for Tight Loop MVP
â”‚   â”œâ”€â”€ rules/                  # Additional Cursor rule files
â”‚   â””â”€â”€ drop-in_template_A.mdc  # Planner â†” Executor recursive handshake template
â”œâ”€â”€ codex.md                    # Planner-focused guidelines
â”œâ”€â”€ watcher/                    # Self-recovery script package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ watcher.py
â”‚   â””â”€â”€ requirements.txt
â”œâ”€â”€ start_codex.sh              # Zsh launcher for Codex Planner
â”œâ”€â”€ start_cursor_with_watcher.sh # Launches Codex and Watcher simultaneously
â”œâ”€â”€ send_codex_plan_request.sh # Script to send plan requests to Codex Planner.
â””â”€â”€ README.md                   # Setup & usage instructions
```

### 4.2 Execution Workflow
1.  **Install deps**: `python3 -m pip install -r watcher/requirements.txt`  
2.  **Launch Cursor Executor via wrapper**:  
     ```bash
     python watcher/watcher.py -- cursor run_executor_command_here
     ```
3.  The wrapper starts the specified command, streams output, triggers recovery when needed, and exits when the child process ends.

### 4.3 Auto-Restart & Template Enforcement
Besides listening for `Exceeded 25 native tool calls`, the **Watcher** now has two new responsibilities:

1. **Template Enforcement**
   - Every time Cursor Assistant outputs a *type 2 bubble* (i.e., assistant response), the Watcher should scan the bubble's text to confirm that it ends with the `@drop-in_template_A.mdc` specified **Template A â€“ Plan-and-Execute Loop** fragment (this can be achieved by searching for `### ðŸ”„  Template A` or other unique anchor points).
   - If the template ending is not detected within a grace period (e.g., 3 seconds), immediately trigger the same GUI recovery process as FR-S2â€“S4 to ensure the Planner receives a new **Prompt Aâ‚™**.
   - Relevant log keywords: `TEMPLATE_MISSING` (triggered), `TEMPLATE_ENFORCED` (GUI input complete).

2. **One-Click Startup Script**
   - Add `start_cursor_with_watcher.sh` (or equivalent Makefile target). Script flow:
     ```bash
     #!/usr/bin/env bash
     set -euo pipefail

     # 1. Start Codex Planner (background)
     ./start_codex.sh &
     CODex_PID=$!

     # 2. Start Watcher with Cursor Executor command
     #    Here, it is assumed that the cursor executor command is