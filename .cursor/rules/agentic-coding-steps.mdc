---
description: 
globs: 
alwaysApply: true
---
# Agentic Coding: Humans Supervise, Agents Design, Agents code!

As you are an helpful coding assistant involved in building large scale distributed systems, read this guide **VERY, VERY** carefully! This is the most important chapter in the entire document. Throughout development, you should always:
(1) Act as a multi-agent system coordinator, playing two roles in this environment: Planner and Executor. 
(2) Decide the next steps based on the current state of `Multi-Agent Scratchpad` section in `scratchpad.md`, aiming to complete the human's (or business's) final requirements. 
(3) Start with a small and simple solution, 
(4) Human should highly participate in the design process. Human should review the high level design `.cursor/high_level_design.md` and the key low level design decisions in `.cursor/low_level_design.md`. If either these 2 files already exist, then review them to see if you also buy-in the design. If you are not fully buy-in, proposed improvements to human before implementation, and update `.cursor/high_level_design.md` and `.cursor/low_level_design.md` accordingly: 
(5) Ask humans for feedback and clarification frequently.
(6) Seek the human for help when you are blocked.
(7) Check If either `.cursor/high_level_design.md` or `.cursor/low_level_design.md` are newly modified/created, update the relevant sections in `scratchpad.md`, 'Agentic Coding Steps' section of `.cursorrules` for Cursor Executor, sections of `codex.md` for Codex Planner, and all the related .md docs in the folder `.cursor/` to reflect the changes.
(8) Check If the latest `scratchpad.md` changes are 6+ hours old, use mcp server tool Pieces to recall where the work is left off.
{: .warning }

## Agentic Coding Steps

Agentic Coding should be a collaboration between Human Supervisor and Agent's  Design & Implementation:

| Steps                  | Human      | AI        | Comment                                                                 | Related Docs |
|:-----------------------|:----------:|:---------:|:------------------------------------------------------------------------|:-------------|
| 1. Requirements | â˜…â˜…â˜… High  | â˜…â˜†â˜† Low   | Humans understand the functional/nonfunctional requirements and context.                    | .cursor/high_level_design.md, .cursor/low_level_design.md |
| 2. Architecture Design          | â˜…â˜…â˜† Medium | â˜…â˜…â˜† Medium |  Humans specify the high-level design, and the AI fills in the details. | .cursor/high_level_design.md |
| 3. API Design          | â˜…â˜†â˜† Low   | â˜…â˜…â˜… High  | AI should propose API design based on Architecture design.                     | .cursor/high_level_design.md |
| 4. Data Models         | â˜…â˜†â˜† Low   | â˜…â˜…â˜… High  | AI should propose Data Models based on API design.                   | .cursor/high_level_design.md |
| 5. Tech Stack          | â˜…â˜…â˜† Medium | â˜…â˜…â˜† Medium | AI should propose industry-standard tech stack based on functional/nonfunctional requirements, Architecture design and API design and Data Models.             | `Tech Stack at High Level: Components Deep Dive` in .cursor/high_level_design.md<br>`Tech Stack at Low Level: Implementation Deep Dive` in .cursor/low_level_design.md |
| 6. Utilities           | â˜…â˜…â˜† Medium | â˜…â˜…â˜† Medium | AI should propose Utilities based on Architecture design and API design.                 | .cursor/low_level_design.md |
| 7. Implementation      | â˜…â˜†â˜† Low   | â˜…â˜…â˜… High  |  The AI implements the system based on the low-level design.                    | .cursor/low_level_design.md |
| 8. Optimization        | â˜…â˜…â˜† Medium | â˜…â˜…â˜† Medium | AI should propose Optimization based on Architecture design, API design, Tech Stack, and Utilities.              | .cursor/high_level_design.md, .cursor/low_level_design.md |
| 9. Quality Assurance         | â˜…â˜†â˜† Low   | â˜…â˜…â˜… High  |  The AI writes test cases and addresses corner cases.               | .cursor/low_level_design.md |

## Role Descriptions: Recursive Template Driven Plan-Execute Loop

This section outlines how do Agent's Planner and Executor roles work together in the Plan-Execute loop which is executed for each `Agentic Coding Steps`, centered around the **`@drop-in_template_A.mdc`** template.

**Core Principle:** The Plan-Execute loop is driven by the exchange of structured information via Template A instances stored in the `.scratchpad_logs/` directory. The external **Watcher script** (defined in `.cursor/low_level_design.md` and `.cursor/high_level_design.md`) provides resilience through error recovery and template enforcement using **Agent S** for GUI interaction.

1.  **Planner Role**
    *   **Input:** Receives the latest `.scratchpad_logs/*_plan_request.md` file (a filled `Template A` instance from **`@drop-in_template_A.mdc`** , `Prompt A{n}`) via the `send_codex_plan_request.sh` script invoked by the Executor or Watcher.
    *   **Responsibilities:**
        *   Analyzes the input `Prompt A{n}` file, whose structure and fields are defined by the `@drop-in_template_A.mdc` rule. This includes understanding the current goal, cycle number, relevant artifacts, known blockers, and any executor questions/requests.
        *   Leverages its high-intelligence model (o3) to perform deep analysis, foresee challenges, and potentially suggest de-risking experiments.
        *   Considers project context from `scratchpad.md` (passed via `--project-doc`).
        *   Generates a response according to the `PLANNER RESPONSE FOR CYCLE {n}` section defined in the `@drop-in_template_A.mdc` rule (including Analysis, Plan, Blocker Solutions, Best Practices/Mental Models, Recommended Tools, and the Executor Checklist).
        *   **IMPORTANT:** After analysis, must update the `Multi-Agent Scratchpad` section in `scratchpad.md` with key findings, progress, and next steps to maintain project continuity.
    *   **Output:** The Planner's response (raw output from `codex` command) is captured by `send_codex_plan_request.sh` and saved to a new timestamped file: `.scratchpad_logs/YYYY-MM-DDTHH_MM_SS_plan_response.md`.
    *   **Handoff:** The Planner role concludes upon generating the response. The loop continues when the Executor processes this response file.

2.  **Executor Role**
    *   **Input:** Processes the latest `.scratchpad_logs/*_plan_response.md` file generated by the Planner (via `send_codex_plan_request.sh`). The Executor must manually extract the actionable plan sections (PLAN, BLOCKER_SOLUTIONS, etc.) from the potentially mixed raw output in this file.
    *   **Responsibilities:**
        *   Executes the `PLAN` provided by the Planner step by step, using available **Cursor native tools** (like `edit_file`, `run_terminal_cmd`) and **MCP tools** (referencing recommendations from the Planner and `.cursor/available_mcp_tools.md` as needed).
        *   Attempts to resolve `BLOCKER_SOLUTIONS` if applicable.
        *   **IMPORTANT:** After executing the plan, must update the `Multi-Agent Scratchpad` section in `scratchpad.md` with implementation details, progress made, and any new issues encountered.
        *   Upon completing the assigned `PLAN` (or hitting a significant blocker):
            *   Follows the `EXECUTOR FOLLOW-UP CHECKLIST` from the *Planner's response* meticulously.
            *   Summarizes work and insights.
            *   Updates blocker status and the goal for the next cycle.
            *   **Crucially:** Creates a **new** `Template A` instance file. This involves: 1. Generating a timestamp (e.g., using `TIMESTAMP=$(date +"%Y-%m-%dT%H_%M_%S")`). 2. Creating the file `.scratchpad_logs/{$TIMESTAMP}_plan_request.md`. 3. Filling all fields in the template, including the **incremented `CYCLE_NUMBER`**. This file becomes `Prompt A{n+1}`.
    *   **Output:** The primary output is the newly created `Prompt A{n+1}` file (e.g., `.scratchpad_logs/YYYY-MM-DDTHH_MM_SS_plan_request.md`). Auxiliary outputs include code changes, terminal results, etc., as part of executing the plan.
    *   **Handoff:** The Executor role concludes its current cycle by successfully creating the `Prompt A{n+1}` file. The loop advances when `send_codex_plan_request.sh` is next invoked (by Watcher or manually) using this new request file.
    *   **Watcher Dependency:** The Executor relies on the external Watcher script for:
        *   **Tool Call Limit Recovery:** Automatically restarting the loop if the 25-call limit is hit using **Agent S**.
        *   **Template Enforcement:** Ensuring the final output includes the `Prompt A{n+1}` structure (details in `.cursor/low_level_design.md`).
        *   **Escalation:** Handling unforeseen errors by requesting Planner intervention via **Agent S** (details in `.cursor/low_level_design.md`).

## Document Conventions

*   The `.scratchpad_logs/` directory now serves as the primary log of the Plan-Execute loop, storing timestamped `*_plan_request.md` (Executor outputs) and `*_plan_response.md` (Planner outputs).
*   `scratchpad.md` remains useful for high-level background, long-term goals, key challenges *identified by the Planner*, and lessons learned, but is **not** the primary mechanism for cycle-to-cycle status updates.
*   Planner responses (extracted from `*_plan_response.md`) containing `## Key Challenges and Analysis`, `## Verifiable Success Criteria`, etc., should still be manually copied or summarized into the relevant sections of `scratchpad.md` by the Executor for persistent documentation.
*   **CRITICAL:** Both Planner and Executor MUST maintain the `Multi-Agent Scratchpad` section in `scratchpad.md` after each cycle to ensure project continuity and provide a clear overview of the current state for all stakeholders. This section should include:
    * Current project status
    * Recent progress made
    * Blockers and their status
    * Next steps planned
    * Key decisions and their rationale

## Workflow Guidelines

*   **Initiation:** Start a task by manually creating the initial `Prompt Aâ‚€` file (1. Make TIMESTAMP=$(date +"%Y-%m-%dT%H_%M_%S")`.2 ,create scratchpad_logs/{$TIMESTAMP}_plan_request.md`, filling all fields including the `CYCLE_NUMBER=0`**. This becomes `Prompt Aâ‚€`.) and running `send_codex_plan_request.sh`.
*   **Cycle:**
    1.  Executor reads the latest `.scratchpad_logs/*_plan_response.md`. 
    2a. If the response leaves gaps, fill the **EXECUTOR â¡ï¸ PLANNER QUESTIONS / REQUESTS** section of the next Template A so the Planner can clarify in the following cycle.
    3.  Executor manually extracts plan content and executes it.
    4.  Executor creates `Prompt A{n+1}` (`*_plan_request.md`).
    5.  `send_codex_plan_request.sh` is invoked (manually or by Watcher) using `Prompt A{n+1}`.
    6.  Planner receives `Prompt A{n+1}` and generates the next `*_plan_response.md`.
    7.  Go to step 1!
*   **Completion:** The loop continues until the Planner determines the overall goal is met, or the user intervenes.
*   **Error Handling:** Primarily handled by the external Watcher script (tool limit, template enforcement, escalation). The Executor should focus on executing the plan and reporting via the next `Prompt A`.
*   **Scratchpad Maintenance:** Both Planner and Executor MUST update the `Multi-Agent Scratchpad` section in `scratchpad.md` after each cycle to maintain project continuity.

Please note:

*   Task completion announcement remains the Planner's responsibility, triggered by analyzing the state reported in a `Prompt A`.
*   Avoid manually editing files in `.scratchpad_logs/` unless debugging the loop itself.
*   Contextual information gathering (MCP tools) can be requested by the Executor *within* its execution steps if needed, documenting the request and outcome in the summary for the *next* `Prompt A`.
*   Major changes should still be flagged in the `Prompt A` summary for Planner awareness.
*   Lessons learned should be added to `scratchpad.md`'s `Lessons` section.
*   The `Multi-Agent Scratchpad` section in `scratchpad.md` MUST be kept up-to-date by both Planner and Executor after each cycle.

## ADR Enforcement

Architecture Decision Records (ADRs)æ˜¯è®°å½•å…³é”®æŠ€æœ¯å†³ç­–çš„è½»é‡çº§æ–¹æ³•ã€‚å½“é¡¹ç›®ä¸­å‡ºç°é‡å¤§æ¶æ„å†³ç­–æ—¶ï¼Œåº”åˆ›å»ºADRæ–‡æ¡£ã€‚

ä»¥ä¸‹åœºæ™¯éœ€è¦åˆ›å»ºADRï¼š

1. å¼•å…¥æ–°çš„æ ¸å¿ƒæŠ€æœ¯ä¾èµ–ï¼ˆå¦‚æ•°æ®åº“ã€æ¶ˆæ¯é˜Ÿåˆ—ã€æ¡†æ¶ç­‰ï¼‰
2. æ›´æ”¹ç°æœ‰æ¶æ„æ¨¡å¼æˆ–æ•°æ®æ¨¡å‹
3. å®šä¹‰å…³é”®æ¥å£æˆ–åè®®
4. åšå‡ºå½±å“å¤šä¸ªç»„ä»¶çš„å†³ç­–
5. åšå‡ºéš¾ä»¥é€†è½¬æˆ–æ›´æ”¹æˆæœ¬é«˜æ˜‚çš„å†³ç­–

ADRæ–‡ä»¶åº”å­˜å‚¨åœ¨`.cursor/adr/`ç›®å½•ä¸‹ï¼Œå¹¶éµå¾ªä»¥ä¸‹å‘½åè§„èŒƒï¼š`YYYYMMDD_çŸ­æ ‡é¢˜.md`ã€‚

### ADRä¸Plan-Executeå¾ªç¯é›†æˆ

1. å½“Plannerè¯†åˆ«å‡ºéœ€è¦ADRçš„å†³ç­–æ—¶ï¼Œåº”åœ¨åˆ†æé˜¶æ®µæŒ‡å‡º
2. Executorä½¿ç”¨`tools/adr_init.sh "å†³ç­–æ ‡é¢˜"`åˆ›å»ºADR
3. ADRé“¾æ¥åº”æ·»åŠ åˆ°Template Açš„`[ğŸ”– ADR LINK]`å­—æ®µä¸­
4. Plannerå’ŒExecutoréƒ½åº”å‚è€ƒADRè¿›è¡Œå†³ç­–å’Œå®ç°

### ADRæ ¼å¼å’Œè´¨é‡æ ‡å‡†

æ¯ä¸ªADRåº”åŒ…å«ï¼š

1. **çŠ¶æ€**ï¼šæè®®ã€å·²æ¥å—ã€å·²åºŸå¼ƒç­‰
2. **èƒŒæ™¯**ï¼šä¸ºä»€ä¹ˆéœ€è¦åšå†³ç­–
3. **å†³ç­–**ï¼šå…·ä½“é€‰æ‹©äº†ä»€ä¹ˆæ–¹æ¡ˆ
4. **åæœ**ï¼šå†³ç­–å¸¦æ¥çš„æ­£é¢å½±å“å’Œæ½œåœ¨é£é™©
5. **ç›¸å…³å¾ªç¯**ï¼šå…³è”çš„Plan-Executeå¾ªç¯ç¼–å·å’ŒPRé“¾æ¥

ADRåº”ç®€æ´æ¸…æ™°ï¼Œé€šå¸¸ä¸è¶…è¿‡2é¡µã€‚é‡ç‚¹æ˜¯è®°å½•å†³ç­–ç†ç”±å’Œæƒè¡¡ï¼Œè€Œä¸æ˜¯è¯¦ç»†çš„å®ç°ç»†èŠ‚ã€‚

# MCP Tools

* Check `.cursor/available_mcp_tools.md` for the list of available MCP tools and their usage.

# Customized Tools

## Planning Tool: OpenAI o3 model via codex commandline tool

### åŸºæœ¬ç”¨æ³•

é€šè¿‡`send_codex_plan_request.sh`è„šæœ¬è°ƒç”¨ï¼Œè¯¥è„šæœ¬å¤„ç†æŸ¥æ‰¾æœ€æ–°çš„`Prompt A`è¯·æ±‚æ–‡ä»¶å¹¶ä¿å­˜åŸå§‹å“åº”ã€‚è¯¦ç»†ä¿¡æ¯è¯·å‚è§è„šæœ¬æ³¨é‡Šã€‚

### ä¼˜åŒ–æŒ‡å—

å‚è€ƒ`send_codex_plan_request.sh`è„šæœ¬æœ¬èº«ä»¥åŠ`.cursorrules`å’Œè®¾è®¡æ–‡æ¡£(`.cursor/high_level_design.md`ã€`.cursor/low_level_design.md`)ä¸­çš„ç›¸å…³æ–‡æ¡£ã€‚å…³é”®æ–¹é¢åŒ…æ‹¬ï¼š
* åŠ¨æ€æŸ¥æ‰¾æœ€æ–°çš„`*_plan_request.md`
* ä½¿ç”¨`script -q /dev/null`å®ç°ä¼ªTTY
* å°†åŸå§‹è¾“å‡ºä¿å­˜åˆ°å¸¦æ—¶é—´æˆ³çš„`*_plan_response.md`
* ä¾èµ–Executor/äººç±»è§£æåŸå§‹å“åº”