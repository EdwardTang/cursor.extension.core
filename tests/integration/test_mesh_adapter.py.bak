#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import unittest
from unittest.mock import MagicMock, patch
import time

# 导入实际实现
from oppie.tool_proxy import GlobalCounter
from oppie.types import Msg, CounterUpdateMsg

# 同步事件总线模拟
class EventBusMock:
    """模拟事件总线，但使用同步方式工作"""
    
    def __init__(self):
        self.listeners = []  # 监听器列表
    
    def add_listener(self, listener):
        """添加监听器"""
        self.listeners.append(listener)
    
    def remove_listener(self, listener):
        """移除监听器"""
        if listener in self.listeners:
            self.listeners.remove(listener)
    
    def put(self, event):
        """同步放入事件，并通知所有监听器"""
        for listener in self.listeners:
            if listener['node_id'] != event['source_id']:
                listener['handler'](event)
        return True
    
    async def put_async(self, event):
        """异步API兼容方法"""
        return self.put(event)

# 模拟的MeshAdapter
class MeshAdapterMock:
    """为测试目的而模拟的MeshAdapter"""
    
    def __init__(self, node_id, event_bus):
        self.node_id = node_id
        self.event_bus = event_bus
        self.core = None
        self.tool_proxy = None
        self.connected = True
        self.state = {
            "cursor_position": 0,
            "last_msg_id": None,
            "timestamp": int(time.time() * 1000)
        }
        self.last_heartbeat_received = {}
        
        # 注册事件处理器
        self.event_bus.add_listener({
            'node_id': self.node_id,
            'handler': self._handle_event
        })
    
    def _handle_event(self, event):
        """处理事件"""
        if not self.connected:
            return
        
        if event['type'] == 'message':
            if self.core:
                self.core.handle_message(event['data'])
        
        elif event['type'] == 'counter_update':
            if self.tool_proxy:
                self.tool_proxy.apply_counter_update(event['data'])
        
        elif event['type'] == 'state_sync':
            new_state = event['data']
            source_id = event['source_id']
            # 冲突解决：使用时间戳较新的状态
            if new_state.get('timestamp', 0) > self.state.get('timestamp', 0):
                self.state.update(new_state)
        
        elif event['type'] == 'heartbeat':
            source_id = event['source_id']
            self.last_heartbeat_received[source_id] = time.time()
    
    def start(self):
        """启动适配器"""
        return True
    
    async def start_async(self):
        """异步API兼容方法"""
        return self.start()
    
    def shutdown(self):
        """关闭适配器"""
        self.event_bus.remove_listener({
            'node_id': self.node_id,
            'handler': self._handle_event
        })
        return True
    
    async def shutdown_async(self):
        """异步API兼容方法"""
        return self.shutdown()
    
    def broadcast(self, msg):
        """广播消息"""
        if not self.connected:
            return False
        
        event = {
            'type': 'message',
            'source_id': self.node_id,
            'data': msg
        }
        
        return self.event_bus.put(event)
    
    async def broadcast_async(self, msg):
        """异步API兼容方法"""
        return self.broadcast(msg)
    
    def broadcast_counter_update(self, update_msg):
        """广播计数器更新"""
        if not self.connected:
            return False
        
        event = {
            'type': 'counter_update',
            'source_id': self.node_id,
            'data': update_msg
        }
        
        return self.event_bus.put(event)
    
    async def broadcast_counter_update_async(self, update_msg):
        """异步API兼容方法"""
        return self.broadcast_counter_update(update_msg)
    
    def sync_state(self):
        """同步状态"""
        if not self.connected:
            return False
        
        # 更新时间戳
        self.state['timestamp'] = int(time.time() * 1000)
        
        event = {
            'type': 'state_sync',
            'source_id': self.node_id,
            'data': self.state
        }
        
        return self.event_bus.put(event)
    
    async def sync_state_async(self):
        """异步API兼容方法"""
        return self.sync_state()
    
    def disconnect(self):
        """断开连接"""
        self.connected = False
        return True
    
    async def disconnect_async(self):
        """异步API兼容方法"""
        return self.disconnect()
    
    def reconnect(self):
        """重新连接"""
        self.connected = True
        return True
    
    async def reconnect_async(self):
        """异步API兼容方法"""
        return self.reconnect()


class TestMeshAdapter(unittest.TestCase):
    """测试MeshAdapter组件的集成功能，特别是节点间同步"""
    
    def setUp(self):
        """每个测试前的准备工作"""
        # 创建模拟事件总线
        self.event_bus = EventBusMock()
        
        # 创建模拟的MeshAdapter节点
        self.nodes = [
            MeshAdapterMock(node_id=f"node{i}", event_bus=self.event_bus) 
            for i in range(1, 4)
        ]
        
        # 创建全局计数器和工具代理
        self.counter = GlobalCounter()
        self.mock_tool = MagicMock()
        self.mock_tool.name = "test_tool"
        self.mock_tool.invoke = MagicMock(return_value={"result": "success"})
        
        # 为每个节点创建工具代理模拟
        self.tool_proxies = []
        for i, node in enumerate(self.nodes):
            proxy = MagicMock()
            proxy.node_id = f"node{i+1}"
            proxy.call_count = 0
            
            # 模拟apply_counter_update方法
            def make_apply_fn(proxy_obj):
                def apply_counter_update(update_msg):
                    if update_msg.counter_type == "tool_call":
                        proxy_obj.call_count += update_msg.delta
                return apply_counter_update
            
            proxy.apply_counter_update = make_apply_fn(proxy)
            
            # 模拟invoke方法
            def make_invoke_fn(proxy_obj, node_obj):
                def invoke(*args, **kwargs):
                    proxy_obj.call_count += 1
                    
                    # 广播计数器更新
                    update_msg = CounterUpdateMsg(
                        node_id=proxy_obj.node_id,
                        delta=1,
                        counter_type="tool_call"
                    )
                    node_obj.broadcast_counter_update(update_msg)
                    
                    return {"result": "success"}
                return invoke
            
            proxy.invoke = make_invoke_fn(proxy, node)
            
            self.tool_proxies.append(proxy)
            node.tool_proxy = proxy
        
        # 为每个节点创建一个模拟的CursorCore
        for node in self.nodes:
            node.core = MagicMock()
            node.start()  # 启动节点
    
    def tearDown(self):
        """每个测试后的清理工作"""
        for node in self.nodes:
            node.shutdown()
    
    def test_mesh_message_propagation(self):
        """测试消息在网格中的传播"""
        # 创建一个测试消息
        msg = Msg(type="runPlan", plan=[])
        
        # 节点1发送消息
        self.nodes[0].broadcast(msg)
        
        # 验证其他节点收到了消息
        for i in range(1, 3):
            self.nodes[i].core.handle_message.assert_called_once()
            call_args = self.nodes[i].core.handle_message.call_args[0][0]
            self.assertEqual(call_args.type, "runPlan")
    
    def test_node_disconnect_reconnect(self):
        """测试节点断开连接后重新连接"""
        # 重置所有模拟
        for node in self.nodes:
            node.core.handle_message.reset_mock()
        
        # 模拟节点2断开连接
        self.nodes[1].disconnect()
        
        # 创建消息
        msg = Msg(type="runPlan", plan=[])
        
        # 节点1发送消息
        self.nodes[0].broadcast(msg)
        
        # 验证节点3收到了消息，节点2没有收到
        self.nodes[2].core.handle_message.assert_called_once()
        self.nodes[1].core.handle_message.assert_not_called()
        
        # 重置模拟
        for node in self.nodes:
            node.core.handle_message.reset_mock()
        
        # 模拟节点2重新连接
        self.nodes[1].reconnect()
        
        # 节点1再次发送消息
        msg2 = Msg(type="chat", prompt="test")
        self.nodes[0].broadcast(msg2)
        
        # 验证所有节点都收到了新消息
        for i in range(1, 3):
            self.nodes[i].core.handle_message.assert_called_once()
            call_args = self.nodes[i].core.handle_message.call_args[0][0]
            self.assertEqual(call_args.type, "chat")
            self.assertEqual(call_args.prompt, "test")
    
    def test_mesh_sync_state(self):
        """测试网格节点间的状态同步"""
        # 设置初始状态
        for node in self.nodes:
            node.state = {"cursor_position": 0, "last_msg_id": None, "timestamp": 100}
        
        # 节点1更新状态
        self.nodes[0].state["cursor_position"] = 42
        self.nodes[0].state["last_msg_id"] = "msg_123"
        self.nodes[0].state["timestamp"] = 200
        
        # 触发状态同步
        self.nodes[0].sync_state()
        
        # 验证其他节点状态已同步
        for i in range(1, 3):
            self.assertEqual(self.nodes[i].state["cursor_position"], 42)
            self.assertEqual(self.nodes[i].state["last_msg_id"], "msg_123")
            self.assertEqual(self.nodes[i].state["timestamp"], 200)
    
    def test_mesh_conflict_resolution(self):
        """测试网格冲突解决机制"""
        # 同时在多个节点上更新状态（制造冲突）
        self.nodes[0].state = {"cursor_position": 10, "timestamp": 100}
        self.nodes[1].state = {"cursor_position": 20, "timestamp": 200}  # 更新时间戳
        self.nodes[2].state = {"cursor_position": 30, "timestamp": 150}
        
        # 触发状态同步
        self.nodes[0].sync_state()
        self.nodes[1].sync_state()
        self.nodes[2].sync_state()
        
        # 验证所有节点都采用了时间戳最大的状态（来自节点2）
        for node in self.nodes:
            self.assertEqual(node.state["cursor_position"], 20, 
                            f"节点{node.node_id}的cursor_position应为20，实为{node.state['cursor_position']}")
            self.assertEqual(node.state["timestamp"], 200, 
                            f"节点{node.node_id}的timestamp应为200，实为{node.state['timestamp']}")
    
    def test_counter_update_propagation(self):
        """测试计数器更新消息在网格中的传播"""
        # 重置计数器
        for proxy in self.tool_proxies:
            proxy.call_count = 0
        
        # 使用第一个节点的工具代理调用工具
        self.tool_proxies[0].invoke("arg1", "arg2")
        
        # 验证所有节点都收到了更新，总计数应该是1
        for proxy in self.tool_proxies:
            self.assertEqual(proxy.call_count, 1, 
                            f"节点{proxy.node_id}的计数应为1，实为{proxy.call_count}")
        
        # 使用第二个节点的工具代理调用工具
        self.tool_proxies[1].invoke("arg3", "arg4")
        
        # 验证所有节点都收到了更新，总计数应该是2
        for proxy in self.tool_proxies:
            self.assertEqual(proxy.call_count, 2, 
                            f"节点{proxy.node_id}的计数应为2，实为{proxy.call_count}")
    
    def test_heartbeat_mechanism(self):
        """测试心跳机制"""
        # 手动发送心跳
        for node in self.nodes:
            # 创建心跳事件并放入事件总线
            heartbeat_event = {
                "type": "heartbeat",
                "source_id": node.node_id,
                "timestamp": time.time()
            }
            self.event_bus.put(heartbeat_event)
        
        # 验证每个节点都收到了其他节点的心跳
        for node in self.nodes:
            for i in range(1, 4):
                peer_id = f"node{i}"
                if peer_id != node.node_id:
                    self.assertIn(peer_id, node.last_heartbeat_received)

if __name__ == "__main__":
    unittest.main() 